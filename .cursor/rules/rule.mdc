---
alwaysApply: true
---

# チャットルール
- 質問に文章で回答するときは、mdファイルを作成せず、チャットに表示すること。

# Next.js コーディング標準

## 環境変数

- `@/lib/env`から環境変数を取得する。

```typescript
import { env } from '@/lib/env'
const apiUrl = env.INT_API_URL
```

## JSDocコメント

- すべての公開関数にJSDocコメントを記述する。

```typescript
/**
 * データを取得する
 *
 * @param id - データID
 * @param options - オプション
 * @returns 取得結果
 * @throws {AppError} データが見つからない場合
 */
```

## ロギング

- `console.log`、`console.error`、`console.warn`の直接使用は禁止。`@/lib/logger`を使用すること。
- ログレベル: `logger.debug()`（開発環境のみ）、`logger.info()`、`logger.warn()`、`logger.error()`
- 本番環境では構造化ログ（JSON形式）として出力される

```typescript
import { logger } from '@/lib/logger'
logger.error('Error message', error)
```

## エラーハンドリング

- `@/lib/errors`の`AppError`クラスと`ErrorCode`を使用すること
- `createAppError()`でエラーを変換し、適切なエラーコードを指定すること

```typescript
import { createAppError, ErrorCode } from '@/lib/errors'
import { logger } from '@/lib/logger'

try {
  // 処理
} catch (error) {
  const appError = createAppError(error, ErrorCode.DATA_NOT_FOUND)
  logger.error('Failed to fetch data', appError)
  return errorResult(appError)
}
```

## Server Actions

- 統一的なエラーハンドリングパターンを使用すること
- `errorResult()`と`successResult()`を使用すること

```typescript
'use server'
import { errorResult, successResult } from '@/lib/action-helpers'
import { logger } from '@/lib/logger'
import { createAppError, ErrorCode } from '@/lib/errors'

export async function myServerAction(
  _prevState: ActionResult<Data> | null,
  formData: FormData
): Promise<ActionResult<Data>> {
  try {
    return successResult(data)
  } catch (error) {
    const appError = createAppError(error, ErrorCode.DATA_NOT_FOUND)
    logger.error('Server action error', appError)
    return errorResult(appError)
  }
}
```

## GraphQLクライアント

- `@/lib/graphql-client`の`executeGraphQLForServerAction`または`executeGraphQLMutation`を使用すること

## 型定義

- 可能な限り明示的な型定義を使用すること

### 型定義の分類と配置

型定義は以下の6つのカテゴリに分類し、適切な場所に配置すること：

#### 1. ドメインエンティティ (`@/core/domain/entity`)

- **用途**: ビジネスロジックの核心となるドメインモデル
- **配置**: `src/core/domain/entity/entity.ts`
- **特徴**:
  - アプリケーション全体で共通して使用される
  - 外部API（GraphQL、FastAPI）に依存しない
  - ビジネスルールを表現する
- **例**: `Homeroom`, `Block`, `Course`, `Subject`, `Instructor`, `ConstraintDefinition` など

```typescript
// ✅ ドメインエンティティ
export interface Homeroom {
  id: string
  homeroomName: string
  homeroomDays: HomeroomDay[]
  blocks: Block[]
  grade?: Grade | null
}
```

#### 2. GraphQL型（各機能ディレクトリの`graphql/types.ts`）

- **用途**: GraphQL API（Spring Boot）との通信で使用する型
- **配置**: 各機能ディレクトリ内の`graphql/types.ts`
- **特徴**:
  - GraphQLスキーマと連動
  - Query/MutationのInput/Response型
  - query/mutation定義とコロケーション（同じディレクトリ内）
  - ドメインエンティティを参照しない（依存関係の明確化のため）
- **命名規則**: 
  - Query Response: `{EntityName}QueryResponse` または `{EntityName}Type`
  - Mutation Input: `{EntityName}Input` または `Upsert{EntityName}Input`
  - Master Response: `{EntityName}MasterResponse`
- **例**: `TimetableResultQueryResponse`, `GraphQLSubjectType`, `UpsertHomeroomsInput`, `ConstraintDefinitionMasterResponse` など

**GraphQLスキーマからTypeScript型へのマッピング規則**:
- GraphQLスキーマの定義に基づいて型を定義する
- **nullableなフィールド**（`Type`、`Int`、`String`など、`!`がついていない）:
  - TypeScriptでは`field?: Type | null`とする
  - GraphQLクエリでフィールドを指定しない場合、レスポンスに含まれない（undefined）
  - GraphQLクエリでフィールドを指定したが値がnullの場合、nullが返される
- **non-nullableなフィールド**（`Type!`、`Int!`、`String!`など、`!`がついている）:
  - TypeScriptでは`field: Type`とする（必須）
  - ただし、GraphQLクエリでフィールドを指定しない場合はレスポンスに含まれないため、実際のクエリで使用するかどうかに応じてoptionalにする場合もある

```typescript
// ✅ GraphQL型（各機能ディレクトリのgraphql/types.ts）
// src/app/(private)/results/[id]/graphql/types.ts
// GraphQLスキーマ: amPeriods/pmPeriodsはInt（nullable）
export interface SchoolDayQueryResponse {
  id: string
  ttid: string
  dayOfWeek: string
  isAvailable: boolean
  amPeriods?: number | null  // nullableなので optional かつ null を許可
  pmPeriods?: number | null
}
```

#### 3. API Route型（各API Route配下）

- **用途**: Next.js API Route（`app/api/`配下）で使用する型
- **配置**: 各API Routeディレクトリ内（例: `src/app/api/optimize/types.ts`）
- **特徴**:
  - API Route専用の型定義
  - GraphQLでカバーできない型のみ定義
  - 各API Routeごとに独立して定義
- **例**: `app/api/optimize/types.ts`内の`OptimizeRequest`, `OptimizeResult` など

```typescript
// ✅ API Route型（各API Route配下）
// src/app/api/optimize/types.ts
export interface OptimizeRequest {
  ttid: string
}

export interface OptimizeResult {
  success: boolean
  data?: unknown
  timetableResultId?: string
  error?: string
  details?: unknown
}
```

#### 4. Server Actions型 (`@/types/server-action-types`)

- **用途**: Server Actionsで使用する統一的な型
- **配置**: `src/types/server-action-types.ts`

#### 5. UI型（各コンポーネントディレクトリの`types.ts`）

- **用途**: UIコンポーネント間のデータ受け渡し、フォーム値、表示用データなど
- **配置**: 各コンポーネントディレクトリ内の`types.ts`
- **特徴**:
  - コンポーネント専用の型定義
  - ドメインエンティティ、GraphQL型でカバーできないもののみ定義
  - フォーム値、モーダル用データ、表示用データなど
  - コンポーネントとコロケーション（同じディレクトリ内）
- **例**: `CourseFormValues`, `ConstraintDefinitionFormValues`, `HomeroomViewData`, `CellData` など

```typescript
export interface CellData {
  subjectName: string
  instructorText: string
  roomText: string
}
```

#### 6. 外部API型（特殊ケース）

- **用途**: 外部API（FastAPIなど）専用の型定義
- **配置**: APIクライアントファイル内（例: `src/lib/fastapi-client.ts`）
- **特徴**:
  - 外部APIの仕様に合わせた型定義
  - ドメインエンティティとは異なる構造を持つ場合がある
  - 変換が必要な場合は、fetcherやhelper関数内で行う
- **例**: `fastapi-client.ts`内の`ConstraintDefinition`, `OptimizeAnnualTimetableRequest` など


### 型定義の使い分けルール

1. **ドメインエンティティを優先**: ビジネスロジックに関わる型は`@/core/domain/entity`に定義
2. **レイヤー間の型定義**: 
   - **同じレイヤー内では重複を避ける**: 同じファイルや同じカテゴリ内で同じ概念の型を複数回定義しない
   - **異なるレイヤー間では意図的な分離を許容**: 依存関係を明確にするため、同じ概念の型を異なるレイヤーで定義することがある
     - 例: `@/core/domain/entity`の`HomeroomDay`と`@/types/graphql-types`の`GraphQLHomeroomDayType`は、レイヤーが異なるため両方定義する
     - 各レイヤーは独立して型を定義し、変換処理で相互に変換する
3. **参照方向**: 
   - GraphQL型、BFF型、UI型 → ドメインエンティティ（参照禁止）
   - ドメインエンティティ → GraphQL型、BFF型、UI型（参照禁止）
   - **重要**: API型（GraphQL型、BFF型、UI型）は`@/core/domain/entity`を参照しない。必要な型は各API型ファイル内で独自に定義する
4. **変換が必要な場合**: APIレスポンスからドメインエンティティへの変換、またはその逆の変換は、fetcherやaction内で行う

### 型定義の命名規則

- **REST APIリクエスト**: `{EntityName}Request` の形式で命名する
  ```typescript
  export interface OptimizeAnnualTimetableRequest {
    ttid: string
    annualData: AnnualData
  }
  ```

- **REST APIレスポンス**: `{EntityName}Response` の形式で命名する
  ```typescript
  export interface OptimizationResponse {
    entries: TimetableEntry[]
    violations: ConstraintViolation[]
  }
  ```

- **GraphQL Input**: `{EntityName}Input` の形式で命名する
  ```typescript
  export interface UpsertHomeroomsInput {
    ttid: string
    homerooms: Homeroom[]
  }
  ```

- **GraphQL Type**: `{EntityName}Type` の形式で命名する
  ```typescript
  export interface GraphQLAnnualDataType {
    schoolDays: GraphQLSchoolDayType[]
    homerooms: GraphQLHomeroomType[]
  }
  ```

- **GraphQL Query Response**: `{EntityName}QueryResponse` または `{EntityName}Type` の形式で命名する
  ```typescript
  export interface TimetableResultQueryResponse {
    id: string
    ttid: string
    timetableEntries: TimetableEntryQueryResponse[]
  }
  
  export interface GraphQLSubjectType {
    id: string
    subjectName: string
  }
  ```

- **GraphQL Mutation Response**: `{EntityName}Response` の形式で命名する（既存のMutationレスポンス型）
  ```typescript
  export interface UpsertHomeroomsResponse {
    id: string
    homeroomName: string
  }
  ```

### インターフェース命名規則

- **コンポーネントのProps**: `{ComponentName}Props` を使用すること
  ```typescript
  interface BlockModalProps {
    isOpen: boolean
    onClose: () => void
  }
  ```

- **フックの引数**: `Use{HookName}Args` を使用すること
  ```typescript
  interface UseBlockModalArgs {
    homeroomId: string | null
    mode: 'create' | 'edit'
  }
  ```

- **理由**: コンポーネントとフックを区別し、型の意図を明確にするため

## インポート順序

1. React関連
2. Next.js関連
3. サードパーティライブラリ
4. 内部モジュール（`@/`エイリアス）
5. 相対パス

## モーダル実装の書き方パターン

- 各モーダルは個別のフックを実装するが、書き方のパターンは統一すること

### エラーハンドリングパターン

```typescript
// エラーメッセージ
const [error, setError] = useState<string | null>(null)

// 保存結果を監視してエラーを表示
useEffect(() => {
  if (saveResult?.success === false) {
    setError(saveResult.error || 'デフォルトエラーメッセージ')
  }
}, [saveResult])

useEffect(() => {
  if (deleteResult?.success === false) {
    setError(deleteResult.error || 'デフォルトエラーメッセージ')
  }
}, [deleteResult])

const clearError = useCallback(() => {
  setError(null)
}, [])
```

### 成功時の処理パターン

```typescript
// 成功時の処理（prevSaveResultRefを使用）
const prevSaveResultRef = useRef<typeof saveResult>(null)
useEffect(() => {
  if (saveResult?.success && saveResult !== prevSaveResultRef.current) {
    reset(initialValues)
    clearError()
    onSuccess()
  }
  prevSaveResultRef.current = saveResult
}, [saveResult, reset, initialValues, clearError, onSuccess])
```

### UI構造パターン

```typescript
<Modal isOpen={isOpen} onClose={handleClose}>
  {/* タイトル表示 */}
  <div className={styles.header}>{title}</div>

  {/* エラー表示 */}
  {error && (
    <div className={styles.errorMessage} role="alert">
      エラー: {error}
    </div>
  )}

  {/* フォーム内容 */}

  <div className={styles.buttonGroup}>
    {/* 保存ボタン */}
    {/* 削除ボタン（編集時のみ） */}
    {/* 閉じるボタン */}
  </div>
</Modal>
```

### 閉じる処理パターン

```typescript
// 閉じる際は状態を初期化
const handleClose = () => {
  reset(initialValues)
  clearError()
  onClose()
}
```
