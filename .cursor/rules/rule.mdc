---
alwaysApply: true
---

# チャットルール

- 質問に文章で回答するときは、mdファイルを作成せず、チャットに表示すること。

# Next.js コーディング標準

## 環境変数

- `@/lib/env`から環境変数を取得する。

```typescript
import { env } from '@/lib/env'
const apiUrl = env.INT_API_URL
```

## JSDocコメント

- すべての公開関数にJSDocコメントを記述する。

```typescript
/**
 * データを取得する
 *
 * @param id - データID
 * @param options - オプション
 * @returns 取得結果
 * @throws {AppError} データが見つからない場合
 */
```

## ロギング

- `console.log`、`console.error`、`console.warn`の直接使用は禁止。`@/lib/logger`を使用すること。
- ログレベル: `logger.debug()`（開発環境のみ）、`logger.info()`、`logger.warn()`、`logger.error()`
- 本番環境では構造化ログ（JSON形式）として出力される

```typescript
import { logger } from '@/lib/logger'
logger.error('Error message', error)
```

## エラーハンドリング

- `@/lib/errors`の`AppError`クラスと`ErrorCode`を使用すること
- `createAppError()`でエラーを変換し、適切なエラーコードを指定すること

```typescript
import { createAppError, ErrorCode } from '@/lib/errors'
import { logger } from '@/lib/logger'

try {
  // 処理
} catch (error) {
  const appError = createAppError(error, ErrorCode.DATA_NOT_FOUND)
  logger.error('Failed to fetch data', appError)
  return errorResult(appError)
}
```

## Server Actions

### ファイル構造と命名規則

- **1ファイル1関数の原則**: 各Server Actionは個別のファイルに定義する
- **ファイル命名規則**: `{actionName}.ts` の形式で命名する
  - 例: `fetchSchoolDays.ts`, `createBlock.ts`, `updateHomeroom.ts`, `deleteCourse.ts`
- **ディレクトリ構造**: `actions/` ディレクトリ配下に配置し、`index.ts`でエクスポートする

```
actions/
├── fetchSchoolDays.ts
├── createBlock.ts
├── updateBlock.ts
├── deleteBlock.ts
└── index.ts
```

### 配置場所の決定規則

Server Actionの配置場所は、**そのServer Actionが「どこで使われているか**で決定する。

#### 「で使われている」の定義

- **コンポーネント内で直接使用**: コンポーネント内（またはそのコンポーネント専用のフック内）で`useActionState`やフォームの`action`属性として直接使用されている場合
- **親コンポーネントで使用**: 親コンポーネントで`useActionState`やフォームの`action`属性として直接使用されている場合

#### 配置規則

1. **特定のコンポーネント専用のServer Action**: そのコンポーネント配下の`actions/`に配置
   - 例: `HomeroomModal`内で使用される`createHomeroom`, `updateHomeroom`, `deleteHomeroom` → `components/HomeroomModal/actions/`
   - 例: `CourseModal`内で使用される`createCourse`, `updateCourse`, `removeCourseFromLane` → `components/CourseModal/actions/`

2. **親コンポーネントで使用されるServer Action**: 親コンポーネントと同じ階層の`actions/`に配置
   - 例: `CurriculumUi.tsx`で直接使用される`fetchHomeroom`, `fetchSchoolDays`, `fetchCourseModalOptions` → `curriculum/actions/`
   - 例: `CurriculumUi.tsx`経由で使用される`createBlock`, `updateBlock`, `deleteBlock` → `curriculum/actions/`

#### 判断基準

- コンポーネント内（またはそのコンポーネント専用のフック内）で`useActionState`を使用している → そのコンポーネント配下の`actions/`
- 親コンポーネントで`useActionState`を使用している → 親コンポーネントと同じ階層の`actions/`

### 関数命名規則

- **取得系**: `fetch{Entity}` の形式で命名する
  - 例: `fetchSchoolDays`, `fetchHomeroom`, `fetchCourseDetails`
- **作成系**: `create{Entity}` の形式で命名する
  - 例: `createBlock`, `createHomeroom`, `createCourse`
- **更新系**: `update{Entity}` の形式で命名する
  - 例: `updateBlock`, `updateHomeroom`, `updateCourse`
- **削除系**: `delete{Entity}` の形式で命名する
  - 例: `deleteBlock`, `deleteHomeroom`, `deleteConstraintDefinition`

### 実装パターン

- **必須インポート**: `'use server'`, `ActionResult`, `errorResult`, `successResult`, `logger`, `createAppError`, `ErrorCode`, `UNKNOWN_ERROR_MESSAGE`
- **取得系**: `executeGraphQLForServerAction`を使用
- **作成・更新・削除系**: `executeGraphQLMutation`を使用し、成功時に`revalidatePath`を呼び出す
- **エラーハンドリング**: GraphQL実行結果のエラーチェックとcatch節の両方を実装
- `console.log`、`console.error`の直接使用は禁止。`logger`と`createAppError`を使用すること

### fetchパターンでの型の使い方

取得系のServer Action（`fetch{Entity}`）では、以下のルールに従うこと：

- **ジェネリクスにGraphQL型を指定**: `executeGraphQLForServerAction`のジェネリクスには、GraphQL共通型（`@/types/graphql-types`）または各機能ディレクトリのGraphQL型（`graphql/types.ts`）を指定する
- **ドメイン型への変換**: GraphQL型からドメイン型（`@/app/(private)/curriculum/types`など）への変換関数を実装し、変換処理を行う
- **必須フィールドのチェック**: 変換関数内で必須フィールドのチェックを行い、欠損している場合はエラーを投げる

#### 実装例

```typescript
'use server'

import type { Course } from '@/app/(private)/curriculum/types'
import type { GraphQLCourse } from '@/app/(private)/curriculum/graphql/types'
import { ActionResult } from '@/types/server-action-types'
import { errorResult, successResult } from '@/lib/action-helpers'
import { executeGraphQLForServerAction } from '@/lib/graphql-client'
import { FETCH_COURSE_DETAILS } from '@/app/(private)/curriculum/graphql/queries'
import { logger } from '@/lib/logger'
import { createAppError, ErrorCode, UNKNOWN_ERROR_MESSAGE } from '@/lib/errors'

/**
 * GraphQL型からCourse型に変換
 *
 * @param graphqlCourse - GraphQL型の講座データ
 * @returns Course型の講座データ
 * @throws {Error} 必須フィールドが欠損している場合
 */
function convertGraphQLCourseToCourse(graphqlCourse: GraphQLCourse): Course {
  if (!graphqlCourse.id) {
    throw new Error('講座IDが取得できませんでした')
  }
  if (!graphqlCourse.courseName) {
    throw new Error('講座名が取得できませんでした')
  }
  // ... 変換処理
}

export async function fetchCourseDetails(
  _prevState: ActionResult | null,
  formData: FormData
): Promise<ActionResult<Course>> {
  try {
    // GraphQL型をジェネリクスに指定
    const result = await executeGraphQLForServerAction<GraphQLCourse[]>({
      query: FETCH_COURSE_DETAILS,
      variables: { input: { id: courseId } },
    }, 'courses')

    if (!result.success || !result.data || result.data.length === 0) {
      const appError = createAppError(
        new Error(result.error || UNKNOWN_ERROR_MESSAGE),
        ErrorCode.DATA_NOT_FOUND
      )
      logger.error(appError.getMessage())
      return errorResult(appError)
    }

    // GraphQL型からドメイン型に変換
    const course = convertGraphQLCourseToCourse(result.data[0])
    return successResult(course)
  } catch (error) {
    const appError = createAppError(error, ErrorCode.DATA_NOT_FOUND)
    logger.error(appError.getMessage())
    return errorResult(appError)
  }
}
```

### エラーハンドリングパターン

すべてのServer Actionsで統一されたエラーハンドリングパターンを使用すること：

#### GraphQL実行結果のエラーチェック

```typescript
if (!result.success || !result.data) {
  const appError = createAppError(
    new Error(result.error || UNKNOWN_ERROR_MESSAGE),
    ErrorCode.DATA_NOT_FOUND // または適切なErrorCode
  )
  logger.error(appError.getMessage())
  return errorResult(appError)
}
```

#### catch節のエラーハンドリング

```typescript
} catch (error) {
  const appError = createAppError(error, ErrorCode.DATA_NOT_FOUND) // または適切なErrorCode
  logger.error(appError.getMessage())
  return errorResult(appError)
}
```

**統一ルール**:

- `UNKNOWN_ERROR_MESSAGE`を使用（文字列リテラル`'不明なエラー'`は禁止）
- `logger.error()`の引数は`appError.getMessage()`のみ（メッセージ文字列は不要）
- `errorResult()`の引数は`appError`オブジェクト（文字列メッセージは不要）

### エラーコードの使い分け

#### エラーの分類

Server Actionsでのエラーは、**システムエラー**と**ユーザー入力エラー**に分類する：

1. **システムエラー（ユーザーにはどうしようもない）**
   - hidden inputで渡される値が欠損している場合（例: `homeroomId`, `blockId`）
   - システム内部のエラー
   - GraphQL実行結果のエラー
   - 例外が発生した場合
   - **実装**: `createAppError` と `ErrorCode` を使用し、`logger.error()` でログに記録する

2. **ユーザー入力エラー（ユーザーが入力する値）**
   - ユーザーが入力するフィールドが空の場合（例: `blockName`, `homeroomName`）
   - バリデーションエラー（例: レーン数が1未満）
   - **実装**: 通常の `errorResult()` を使用（`createAppError` は不要）

#### 実装例

```typescript
// システムエラー: hidden inputで渡される値が欠損している場合
if (!homeroomId) {
  // 学級IDが欠損している場合
  const appError = createAppError(
    new Error('学級IDが指定されていません'),
    ErrorCode.DATA_VALIDATION_ERROR
  )
  logger.error(appError.getMessage())
  return errorResult(appError)
}

// ユーザー入力エラー: ユーザーが入力する値が空の場合
if (!blockName?.trim()) {
  // ブロック名が欠損している場合
  return errorResult('ブロック名を入力してください')
}
```

#### ErrorCodeの使い分け

- **`ErrorCode.DATA_NOT_FOUND`**: データ取得時のエラー
- **`ErrorCode.DATA_VALIDATION_ERROR`**: データ作成・更新・削除時のエラー、システムエラー全般
- **`ErrorCode.DATA_PARSING_ERROR`**: JSONパースエラーなど

### JSDocコメント

- すべてのServer Action関数にJSDocコメントを記述する
- `@param`で各パラメータを説明する
- `@returns`で戻り値を説明する

### index.tsでのエクスポート

- `actions/index.ts`で全関数をエクスポートする
- 型定義も必要に応じてエクスポートする

### ボタンクリックでのServer Action呼び出し

Server Actionをボタンクリックで呼び出す場合、以下の方針に従うこと：

- **ネイティブフォーム（`<form action={...}>`）は使用しない**
  - JSXが重くなり、CSSの適用が困難になる
  - DOM要素が増加し、パフォーマンスに悪影響

- **`onClick`ハンドラー + `startTransition`を使用する**
  - `'use client'`ディレクティブを追加する
  - `startTransition`でServer Actionの呼び出しをラップする
  - `FormData`を作成してServer Actionに渡す

#### 実装パターン

```typescript
'use client'
import { startTransition } from 'react'

const handleClick = () => {
  if (!onAction) return

  const formData = new FormData()
  formData.append('key1', value1)
  formData.append('key2', value2)

  startTransition(() => {
    onAction(formData)
  })
}

return (
  <button type="button" onClick={handleClick}>
    Click me
  </button>
)
```

#### 利点

1. **JSXが軽い**: `<form>`と複数の`<input type="hidden">`が不要
2. **CSSが使いやすい**: `<button>`に直接スタイルを適用可能
3. **コードが簡潔**: `FormData`の構築が関数内で完結
4. **パフォーマンス**: DOM要素の削減により、レンダリングとメモリ使用が改善
5. **UIの応答性**: `startTransition`により、Server Actionの実行が非緊急の更新として扱われ、UIがブロックされない

## GraphQLクライアント

- `@/lib/graphql-client`の`executeGraphQLForServerAction`または`executeGraphQLMutation`を使用すること

### GraphQLクエリ変数の定義規則

GraphQLスキーマでInput型が定義されている場合は、必ずそのInput型を使用すること：

- **Input型を使用**: GraphQLスキーマで`RetrieveXxxInput`などのInput型が定義されている場合、クエリ変数はそのInput型として定義する
- **変数の形式**: `variables: { input: { ... } }`の形式で渡す
- **例**:

  ```typescript
  // ✅ 正しい: Input型を使用
  query GetHomerooms($input: RetrieveHomeroomsInput!) {
    homerooms(input: $input) { ... }
  }

  variables: {
    input: {
      id,
    },
  }

  // ❌ 誤り: 直接値を渡す
  query GetHomerooms($id: ID!) {
    homerooms(input: { id: $id }) { ... }
  }

  variables: {
    id,
  }
  ```

## 型定義

- 可能な限り明示的な型定義を使用すること

### 型定義の分類と配置

型定義は以下の7つのカテゴリに分類し、適切な場所に配置すること：

#### 1. ドメインエンティティ (`@/core/domain/entity`)

- **用途**: ビジネスロジックの核心となるドメインモデル
- **配置**: `src/core/domain/entity/entity.ts`
- **特徴**:
  - アプリケーション全体で共通して使用される
  - 外部API（GraphQL、FastAPI）に依存しない
  - ビジネスルールを表現する
- **例**: `Homeroom`, `Block`, `Course`, `Subject`, `Instructor`, `ConstraintDefinition` など

#### 2. GraphQL共通型 (`@/types/graphql-types`)

- **用途**: GraphQLスキーマに基づく共通型定義
- **配置**: `src/types/graphql-types.ts`
- **特徴**:
  - GraphQLスキーマに定義されているすべての型を定義
  - GraphQLの特性上、クエリで指定したフィールドのみが返されるため、**すべてのフィールドをoptionalにする**
  - nullableなフィールドは`| null`も許可
  - アプリケーション全体で共通して使用される
- **命名規則**: `GraphQL{EntityName}` の形式で命名する
  - 例: `GraphQLSchoolDay`, `GraphQLHomeroom`, `GraphQLSubject`, `GraphQLInstructor` など
- **例**: `GraphQLSchoolDay`, `GraphQLHomeroom`, `GraphQLSubject`, `GraphQLInstructor`, `GraphQLGrade` など

```typescript
// ✅ GraphQL共通型（@/types/graphql-types.ts）
// GraphQLの特性上、すべてのフィールドをoptionalにする
export interface GraphQLSchoolDay {
  id?: string
  ttid?: string
  dayOfWeek?: string
  isAvailable?: boolean
  amPeriods?: number | null // nullableなので null を許可
  pmPeriods?: number | null
}
```

#### 2-1. GraphQL型（各機能ディレクトリの`graphql/types.ts`）

- **用途**: GraphQL API（Spring Boot）との通信で使用する型
- **配置**: 各機能ディレクトリ内の`graphql/types.ts`
- **特徴**:
  - 共通型（`@/types/graphql-types`）を再エクスポート
  - Mutation Input型やResponse型など、機能固有の型を定義
  - query/mutation定義とコロケーション（同じディレクトリ内）
  - ドメインエンティティを参照しない（依存関係の明確化のため）
- **命名規則**:
  - Mutation Input: `{EntityName}Input` または `Upsert{EntityName}Input`
  - Response型: `{EntityName}Response` または `{ActionName}Response`
  - Master Response: `{EntityName}MasterResponse`
- **例**: `UpsertHomeroomsInput`, `HomeroomsAndGradesResponse`, `CourseModalOptionsResponse`, `ConstraintDefinitionMasterResponse` など

```typescript
// ✅ GraphQL型（各機能ディレクトリのgraphql/types.ts）
// src/app/(private)/curriculum/graphql/types.ts
// 共通型を再エクスポート
export type {
  GraphQLSchoolDay,
  GraphQLHomeroom,
  GraphQLGrade,
  // ...
} from '@/types/graphql-types'

// Mutation Input型
export interface UpsertHomeroomsInput {
  ttid: string
  by: string
  homerooms: { ... }[]
}

// Response型
export interface HomeroomsAndGradesResponse {
  homerooms?: GraphQLHomeroom[]
  grades?: GraphQLGrade[]
}
```

#### 3. GraphQL共通型の使用規則

- **共通型を優先**: GraphQLスキーマに定義されている型は`@/types/graphql-types`の共通型を使用する
- **再エクスポート**: 各機能ディレクトリの`graphql/types.ts`では、共通型を`export type`で再エクスポートする
- **型エイリアスは禁止**: 共通型のエイリアス（`export type GraphQLHomeroomType = GraphQLHomeroom`など）は作成しない
- **直接使用**: コード内では共通型を直接使用する（`GraphQLHomeroom`など）

#### 4. API Route型（各API Route配下）

- **用途**: Next.js API Route（`app/api/`配下）で使用する型
- **配置**: 各API Routeディレクトリ内（例: `src/app/api/optimize/types.ts`）
- **特徴**:
  - API Route専用の型定義
  - GraphQLでカバーできない型のみ定義
  - 各API Routeごとに独立して定義
- **例**: `app/api/optimize/types.ts`内の`OptimizeRequest`, `OptimizeResult` など

```typescript
// ✅ API Route型（各API Route配下）
// src/app/api/optimize/types.ts
export interface OptimizeRequest {
  ttid: string
}

export interface OptimizeResult {
  success: boolean
  data?: unknown
  timetableResultId?: string
  error?: string
  details?: unknown
}
```

#### 5. Server Actions型 (`@/types/server-action-types`)

- **用途**: Server Actionsで使用する統一的な型
- **配置**: `src/types/server-action-types.ts`

#### 6. UI型（各コンポーネントディレクトリの`types.ts`）

- **用途**: UIコンポーネント間のデータ受け渡し、フォーム値、表示用データなど
- **配置**: 各コンポーネントディレクトリ内の`types.ts`
- **特徴**:
  - コンポーネント専用の型定義
  - ドメインエンティティ、GraphQL型でカバーできないもののみ定義
  - フォーム値、モーダル用データ、表示用データなど
  - コンポーネントとコロケーション（同じディレクトリ内）
- **例**: `CourseFormValues`, `ConstraintDefinitionFormValues`, `HomeroomViewData`, `CellData` など

```typescript
export interface CellData {
  subjectName: string
  instructorText: string
  roomText: string
}
```

#### 7. 外部API型（特殊ケース）

- **用途**: 外部API（FastAPIなど）専用の型定義
- **配置**: APIクライアントファイル内（例: `src/lib/fastapi-client.ts`）
- **特徴**:
  - 外部APIの仕様に合わせた型定義
  - ドメインエンティティとは異なる構造を持つ場合がある
  - 変換が必要な場合は、fetcherやhelper関数内で行う
- **例**: `fastapi-client.ts`内の`ConstraintDefinition`, `OptimizeAnnualTimetableRequest` など

### 型定義の使い分けルール

1. **ドメインエンティティを優先**: ビジネスロジックに関わる型は`@/core/domain/entity`に定義
2. **レイヤー間の型定義**:
   - **同じレイヤー内では重複を避ける**: 同じファイルや同じカテゴリ内で同じ概念の型を複数回定義しない
   - **異なるレイヤー間では意図的な分離を許容**: 依存関係を明確にするため、同じ概念の型を異なるレイヤーで定義することがある
     - 例: `@/core/domain/entity`の`HomeroomDay`と`@/types/graphql-types`の`GraphQLHomeroomDay`は、レイヤーが異なるため両方定義する
     - 各レイヤーは独立して型を定義し、変換処理で相互に変換する
3. **参照方向**:
   - GraphQL型、BFF型、UI型 → ドメインエンティティ（参照禁止）
   - ドメインエンティティ → GraphQL型、BFF型、UI型（参照禁止）
   - **重要**: API型（GraphQL型、BFF型、UI型）は`@/core/domain/entity`を参照しない。必要な型は各API型ファイル内で独自に定義する
4. **変換が必要な場合**: APIレスポンスからドメインエンティティへの変換、またはその逆の変換は、fetcherやaction内で行う

### GraphQL型からドメイン型への変換

GraphQL型（`@/types/graphql-types`）からドメイン型（`@/app/(private)/curriculum/types`など）への変換を行う際は、以下のルールに従うこと：

#### 必須フィールドのチェック

- **デフォルト値の設定は禁止**: 必須フィールドが欠損している場合、デフォルト値（空文字列、0、空配列など）を設定してはいけない
- **エラーを投げる**: 必須フィールドが`undefined`または`null`の場合は、エラーを投げる
- **エラーメッセージ**: どのフィールドが欠損しているかを明確に示すエラーメッセージを設定する

#### 実装パターン

```typescript
/**
 * GraphQL型からGrade型に変換
 *
 * @param graphqlGrade - GraphQL型の学年データ
 * @returns Grade型の学年データ
 * @throws {Error} 必須フィールドが欠損している場合
 */
function convertGraphQLGradeToGrade(graphqlGrade: GraphQLGrade): Grade {
  if (!graphqlGrade.id) {
    throw new Error('学年IDが取得できませんでした')
  }
  if (!graphqlGrade.gradeName) {
    throw new Error('学年名が取得できませんでした')
  }

  return {
    id: graphqlGrade.id,
    gradeName: graphqlGrade.gradeName,
    ttid: graphqlGrade.ttid,
  }
}
```

#### ネストされたオブジェクトの変換

ネストされたオブジェクトも同様に、必須フィールドのチェックを行う：

```typescript
function convertGraphQLHomeroomToHomeroom(
  graphqlHomeroom: GraphQLHomeroom
): Homeroom {
  if (!graphqlHomeroom.id) {
    throw new Error('学級IDが取得できませんでした')
  }
  if (!graphqlHomeroom.homeroomName) {
    throw new Error('学級名が取得できませんでした')
  }

  return {
    id: graphqlHomeroom.id,
    homeroomName: graphqlHomeroom.homeroomName,
    grade: graphqlHomeroom.grade
      ? (() => {
          if (!graphqlHomeroom.grade.id) {
            throw new Error('学年IDが取得できませんでした')
          }
          if (!graphqlHomeroom.grade.gradeName) {
            throw new Error('学年名が取得できませんでした')
          }
          return {
            id: graphqlHomeroom.grade.id,
            gradeName: graphqlHomeroom.grade.gradeName,
          }
        })()
      : null,
    homeroomDays: (graphqlHomeroom.homeroomDays || []).map(day => {
      if (!day.id) {
        throw new Error('学級曜日IDが取得できませんでした')
      }
      if (!day.dayOfWeek) {
        throw new Error('曜日が取得できませんでした')
      }
      if (day.periods === undefined || day.periods === null) {
        throw new Error('時限数が取得できませんでした')
      }
      return {
        id: day.id,
        dayOfWeek: day.dayOfWeek,
        periods: day.periods,
      }
    }),
    // ...
  }
}
```

#### エラーハンドリング

変換関数内でエラーが発生した場合、既存の`catch`節でキャッチされ、適切にエラーログが記録される：

```typescript
try {
  const homerooms = (result.data.homerooms || []).map(
    convertGraphQLHomeroomToHomeroom
  )
  // ...
} catch (error) {
  const appError = createAppError(error, ErrorCode.DATA_NOT_FOUND)
  logger.error(appError.getMessage())
  return errorResult(appError)
}
```

### 型定義の命名規則

- **REST APIリクエスト**: `{EntityName}Request` の形式で命名する

  ```typescript
  export interface OptimizeAnnualTimetableRequest {
    ttid: string
    annualData: AnnualData
  }
  ```

- **REST APIレスポンス**: `{EntityName}Response` の形式で命名する

  ```typescript
  export interface OptimizationResponse {
    entries: TimetableEntry[]
    violations: ConstraintViolation[]
  }
  ```

- **GraphQL Input**: `{EntityName}Input` の形式で命名する

  ```typescript
  export interface UpsertHomeroomsInput {
    ttid: string
    homerooms: Homeroom[]
  }
  ```

- **GraphQL Type**: `{EntityName}Type` の形式で命名する

  ```typescript
  export interface GraphQLAnnualDataType {
    schoolDays: GraphQLSchoolDayType[]
    homerooms: GraphQLHomeroomType[]
  }
  ```

- **GraphQL Query Response**: `{EntityName}QueryResponse` または `{EntityName}Type` の形式で命名する

  ```typescript
  export interface TimetableResultQueryResponse {
    id: string
    ttid: string
    timetableEntries: TimetableEntryQueryResponse[]
  }

  export interface GraphQLSubjectType {
    id: string
    subjectName: string
  }
  ```

- **GraphQL Mutation Response**: `{EntityName}Response` の形式で命名する（既存のMutationレスポンス型）
  ```typescript
  export interface UpsertHomeroomsResponse {
    id: string
    homeroomName: string
  }
  ```

### インターフェース命名規則

- **コンポーネントのProps**: `{ComponentName}Props` を使用すること

  ```typescript
  interface BlockModalProps {
    isOpen: boolean
    onClose: () => void
  }
  ```

- **フックの引数**: `Use{HookName}Args` を使用すること

  ```typescript
  interface UseBlockModalArgs {
    homeroomId: string | null
    mode: 'create' | 'edit'
  }
  ```

- **理由**: コンポーネントとフックを区別し、型の意図を明確にするため

## コンポーネントのProps

- **分割代入を使用**: コンポーネントのPropsは分割代入で受け取ること
- `props.`を明示的に使用するのではなく、分割代入を使用する

```typescript
// ✅ 正しい: 分割代入を使用
export default function BlockEntry({
  blockId,
  homeroomId,
  blockName,
  lanes,
  onEditBlock,
}: BlockEntryProps) {
  // ...
}

// ❌ 誤り: props.を明示的に使用
export default function BlockEntry(props: BlockEntryProps) {
  return <div>{props.blockName}</div>
}
```

## インポート順序

1. React関連
2. Next.js関連
3. サードパーティライブラリ
4. 内部モジュール（`@/`エイリアス）
5. 相対パス

## モーダル実装の書き方パターン

- 各モーダルは個別のフックを実装するが、書き方のパターンは統一すること

### エラーハンドリングパターン

```typescript
// エラーメッセージ
const [error, setError] = useState<string | null>(null)

// 保存結果を監視してエラーを表示
useEffect(() => {
  if (saveResult?.success === false) {
    setError(saveResult.error || 'デフォルトエラーメッセージ')
  }
}, [saveResult])

useEffect(() => {
  if (deleteResult?.success === false) {
    setError(deleteResult.error || 'デフォルトエラーメッセージ')
  }
}, [deleteResult])

const clearError = useCallback(() => {
  setError(null)
}, [])
```

### 成功時の処理パターン

```typescript
// 成功時の処理（prevSaveResultRefを使用）
const prevSaveResultRef = useRef<typeof saveResult>(null)
useEffect(() => {
  if (saveResult?.success && saveResult !== prevSaveResultRef.current) {
    reset(initialValues)
    clearError()
    onSuccess()
  }
  prevSaveResultRef.current = saveResult
}, [saveResult, reset, initialValues, clearError, onSuccess])
```

### UI構造パターン

```typescript
<Modal isOpen={isOpen} onClose={handleClose}>
  {/* タイトル表示 */}
  <div className={styles.header}>{title}</div>

  {/* エラー表示 */}
  {error && (
    <div className={styles.errorMessage} role="alert">
      エラー: {error}
    </div>
  )}

  {/* フォーム内容 */}

  <div className={styles.buttonGroup}>
    {/* 保存ボタン */}
    {/* 削除ボタン（編集時のみ） */}
    {/* 閉じるボタン */}
  </div>
</Modal>
```

### 閉じる処理パターン

```typescript
// 閉じる際は状態を初期化
const handleClose = () => {
  reset(initialValues)
  clearError()
  onClose()
}
```
